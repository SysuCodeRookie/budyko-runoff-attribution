# Budykoå¾„æµå½’å› åˆ†æç³»ç»Ÿ - ä»£ç æ’°å†™æ€»ä½“å»ºè®®

**é¡¹ç›®åç§°**: `budyko-runoff-attribution`  
**ç›®æ ‡**: æ„å»ºæ¨¡å—åŒ–ã€å¯ç»´æŠ¤çš„å¾„æµå½’å› åˆ†æPythonæ¡†æ¶  
**é€‚ç”¨å¯¹è±¡**: æ°´æ–‡å­¦ã€åœŸæœ¨å·¥ç¨‹é¢†åŸŸçš„ç§‘ç ”äººå‘˜

---

## ä¸€ã€é¡¹ç›®æ¶æ„æ€»ä½“è®¾è®¡

### 1.1 æ¨èç›®å½•ç»“æ„

```
budyko-runoff-attribution/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ data_preprocessing/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ grdc_parser.py          # GRDCæ•°æ®è§£æ
â”‚   â”‚   â”œâ”€â”€ climate_processor.py    # ISIMIPæ°”å€™æ•°æ®å¤„ç†
â”‚   â”‚   â”œâ”€â”€ pet_calculator.py       # PETè®¡ç®—æ¨¡å—
â”‚   â”‚   â””â”€â”€ water_use_aggregator.py # äººç±»ç”¨æ°´æ•°æ®å¤„ç†
â”‚   â”œâ”€â”€ spatial_analysis/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ basin_extractor.py      # æµåŸŸè¾¹ç•Œæå–ä¸æ©è†œ
â”‚   â”‚   â””â”€â”€ grid_aggregator.py      # ç½‘æ ¼æ•°æ®èšåˆ
â”‚   â”œâ”€â”€ budyko_model/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ core_equations.py       # Budykoæ ¸å¿ƒæ–¹ç¨‹
â”‚   â”‚   â”œâ”€â”€ elasticity_solver.py    # å¼¹æ€§ç³»æ•°è®¡ç®—
â”‚   â”‚   â””â”€â”€ parameter_calibration.py # å‚æ•°nåæ¼”
â”‚   â”œâ”€â”€ attribution/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ budyko_attribution.py   # Budykoå½’å› åˆ†æ
â”‚   â”‚   â””â”€â”€ isimip_attribution.py   # ISIMIPæ¨¡å‹å½’å› 
â”‚   â”œâ”€â”€ validation/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ quality_checks.py       # ç‰©ç†ä¸€è‡´æ€§æ£€éªŒ
â”‚   â””â”€â”€ visualization/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ result_plots.py         # ç»“æœå¯è§†åŒ–
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_grdc_parser.py
â”‚   â”œâ”€â”€ test_budyko_model.py
â”‚   â””â”€â”€ test_attribution.py
â”œâ”€â”€ data/                            # æ•°æ®ç›®å½•ï¼ˆä¸çº³å…¥ç‰ˆæœ¬æ§åˆ¶ï¼‰
â”‚   â”œâ”€â”€ raw/
â”‚   â”œâ”€â”€ processed/
â”‚   â””â”€â”€ results/
â”œâ”€â”€ notebooks/
â”‚   â”œâ”€â”€ 01_data_exploration.ipynb
â”‚   â””â”€â”€ 02_case_study.ipynb
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.yaml                  # é…ç½®æ–‡ä»¶
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ environment.yml                  # Condaç¯å¢ƒé…ç½®
â”œâ”€â”€ README.md
â””â”€â”€ main.py                          # ä¸»è¿è¡Œè„šæœ¬
```

---

## äºŒã€æ ¸å¿ƒæ¨¡å—å®ç°é¡ºåºä¸ä¼˜å…ˆçº§

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ•°æ®å¤„ç†å±‚ï¼ˆç¬¬1-2å‘¨ï¼‰

**ä¼˜å…ˆçº§: â­â­â­â­â­**

#### æ¨¡å—1: `grdc_parser.py`
**ç›®æ ‡**: è§£æGRDCè§‚æµ‹å¾„æµæ•°æ®

**å…³é”®åŠŸèƒ½**:
```python
class GRDCParser:
    def __init__(self, file_path):
        """åˆå§‹åŒ–GRDCæ–‡ä»¶è·¯å¾„"""
        
    def parse_metadata(self) -> dict:
        """æå–ç«™ç‚¹å…ƒæ•°æ®ï¼ˆIDã€åæ ‡ã€é›†æ°´åŒºé¢ç§¯ï¼‰"""
        
    def read_timeseries(self) -> pd.DataFrame:
        """è¯»å–æ—¶é—´åºåˆ—ï¼ˆmÂ³/sï¼‰"""
        
    def convert_to_depth(self, area_km2) -> pd.DataFrame:
        """è½¬æ¢ä¸ºæ°´æ·±ï¼ˆmm/yearï¼‰"""
        
    def aggregate_to_annual(self, water_year=False) -> pd.DataFrame:
        """èšåˆä¸ºå¹´å€¼"""
        
    def quality_filter(self, max_missing_pct=15) -> pd.DataFrame:
        """ç¼ºæµ‹å€¼è¿‡æ»¤"""
```

**å®ç°è¦ç‚¹**:
- ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£æGRDCæ–‡æœ¬æ–‡ä»¶å¤´éƒ¨
- æ³¨æ„é—°å¹´å¤„ç†ï¼š1å¹´ = 365.25å¤©
- å•ä½è½¬æ¢å…¬å¼: `mm/year = (mÂ³/s Ã— 86400 Ã— 365.25) / (area_kmÂ² Ã— 1e6) Ã— 1000`

---

#### æ¨¡å—2: `climate_processor.py`
**ç›®æ ‡**: å¤„ç†ISIMIP NetCDFæ°”å€™æ•°æ®

**å…³é”®åŠŸèƒ½**:
```python
class ClimateDataProcessor:
    def __init__(self, netcdf_path, variable):
        """åˆå§‹åŒ–ï¼ˆå˜é‡ï¼špr, tas, rsdsç­‰ï¼‰"""
        
    def extract_by_basin(self, basin_shapefile) -> xr.DataArray:
        """æ ¹æ®æµåŸŸè¾¹ç•Œæå–å¹¶åŠ æƒå¹³å‡"""
        
    def convert_units(self) -> xr.DataArray:
        """å•ä½è½¬æ¢ï¼ˆkg/mÂ²/s â†’ mm/yearï¼‰"""
        
    def aggregate_to_annual(self) -> pd.Series:
        """æ—¶é—´èšåˆ"""
```

**æŠ€æœ¯éš¾ç‚¹**:
- **ç©ºé—´æ©è†œ**: ä½¿ç”¨ `rioxarray.clip_box()` æˆ– `rasterstats.zonal_stats()`
- **é¢ç§¯åŠ æƒ**: å¯¹äºä¸è§„åˆ™æµåŸŸè¾¹ç•Œï¼Œéœ€è®¡ç®—æ¯ä¸ªç½‘æ ¼ä¸æµåŸŸçš„ç›¸äº¤é¢ç§¯æ¯”ä¾‹
- ä»£ç ç¤ºä¾‹ï¼š
```python
import rioxarray
import geopandas as gpd

# æ‰“å¼€æ°”å€™æ•°æ®å¹¶è®¾ç½®ç©ºé—´å‚è€ƒ
climate = rioxarray.open_rasterio(nc_file).rio.write_crs("EPSG:4326")

# è£å‰ªåˆ°æµåŸŸè¾¹ç•Œ
basin = gpd.read_file(basin_shp)
clipped = climate.rio.clip(basin.geometry, basin.crs, drop=True)

# è®¡ç®—é¢ç§¯åŠ æƒå¹³å‡
weighted_mean = clipped.weighted(clipped.rio.resolution()).mean(dim=['x','y'])
```

---

#### æ¨¡å—3: `pet_calculator.py`
**ç›®æ ‡**: è®¡ç®—FAO-56 Penman-Monteithæ½œåœ¨è’¸æ•£å‘

**æ¨èæ–¹æ¡ˆ**: ç›´æ¥é›†æˆ `pyet` åº“

```python
import pyet

class PETCalculator:
    def __init__(self, climate_data: dict):
        """
        climate_dataåŒ…å«: tmean, tmax, tmin, rs (è¾å°„), 
                          wind, rh (ç›¸å¯¹æ¹¿åº¦), pressure
        """
        
    def calculate_fao56(self) -> pd.Series:
        """è°ƒç”¨pyetè®¡ç®—FAO-56 PET"""
        return pyet.pm_fao56(
            tmean=self.tmean,
            wind=self.wind,
            rs=self.rs,
            rh=self.rh,
            elevation=self.elevation,
            lat=self.latitude
        )
```

**æ³¨æ„äº‹é¡¹**:
- ç¡®ä¿æ‰€æœ‰è¾“å…¥å•ä½ç¬¦åˆpyetè¦æ±‚ï¼ˆæ¸©åº¦ï¼šÂ°Cï¼Œè¾å°„ï¼šMJ/mÂ²/dayï¼‰
- ISIMIPæ•°æ®å•ä½éœ€è½¬æ¢ï¼š`rsds (W/mÂ²) â†’ MJ/mÂ²/day (Ã—0.0864)`

---

### é˜¶æ®µäºŒï¼šBudykoæ¨¡å‹æ ¸å¿ƒå±‚ï¼ˆç¬¬3-4å‘¨ï¼‰

**ä¼˜å…ˆçº§: â­â­â­â­â­**

#### æ¨¡å—4: `core_equations.py`
**ç›®æ ‡**: å®ç°Budyko-Choudhury-Yangæ–¹ç¨‹

```python
import numpy as np

def budyko_evapotranspiration(P, PET, n):
    """
    è®¡ç®—å®é™…è’¸æ•£å‘E
    
    å‚æ•°:
        P: é™æ°´ (mm/year)
        PET: æ½œåœ¨è’¸æ•£å‘ (mm/year)
        n: æµåŸŸå‚æ•° (æ— é‡çº²)
    
    è¿”å›:
        E: å®é™…è’¸æ•£å‘ (mm/year)
    """
    # é˜²æ­¢æ•°å€¼é”™è¯¯
    P = np.maximum(P, 1e-6)
    PET = np.maximum(PET, 1e-6)
    
    numerator = P * PET
    denominator = (P**n + PET**n)**(1/n)
    
    return numerator / denominator

def budyko_runoff(P, PET, n):
    """
    è®¡ç®—å¤©ç„¶å¾„æµQn
    
    Qn = P - E
    """
    E = budyko_evapotranspiration(P, PET, n)
    return P - E
```

**ç‰©ç†çº¦æŸæ£€æŸ¥**:
```python
def validate_water_balance(P, Q, E):
    """
    æ£€æŸ¥æ°´é‡å¹³è¡¡: Q = P - E
    
    è¿”å›: (is_valid, error_message)
    """
    if Q > P:
        return False, f"å¾„æµ({Q:.1f}) > é™æ°´({P:.1f})ï¼Œè¿åæ°´é‡å¹³è¡¡"
    
    if Q < 0:
        return False, f"å¾„æµä¸ºè´Ÿå€¼({Q:.1f})ï¼Œæ•°æ®å¼‚å¸¸"
    
    runoff_ratio = Q / P
    if runoff_ratio > 0.95:
        return False, f"å¾„æµç³»æ•°({runoff_ratio:.2f}) > 0.95ï¼Œç–‘ä¼¼æ•°æ®é”™è¯¯"
    
    return True, "é€šè¿‡æ£€éªŒ"
```

---

#### æ¨¡å—5: `parameter_calibration.py`
**ç›®æ ‡**: åæ¼”æµåŸŸå‚æ•°n

**æ ¸å¿ƒç®—æ³•**:
```python
from scipy.optimize import brentq, OptimizeWarning
import warnings

class BudykoCalibrator:
    def __init__(self, P_obs, PET_obs, Q_obs):
        self.P = P_obs
        self.PET = PET_obs
        self.Q = Q_obs
        
    def calibrate_n(self, n_bounds=(0.1, 10)):
        """
        é€šè¿‡Brentæ–¹æ³•åæ¼”å‚æ•°n
        
        è¿”å›: nå€¼æˆ–Noneï¼ˆå¦‚æœæ— è§£ï¼‰
        """
        def objective(n):
            Q_sim = budyko_runoff(self.P, self.PET, n)
            return Q_sim - self.Q
        
        try:
            with warnings.catch_warnings():
                warnings.filterwarnings('error', category=OptimizeWarning)
                n_opt = brentq(objective, n_bounds[0], n_bounds[1], 
                               xtol=1e-6, maxiter=100)
            return n_opt
        
        except (ValueError, OptimizeWarning) as e:
            # æ— è§£æƒ…å†µï¼šé€šå¸¸å› Q/Pæ¯”ä¾‹ä¸åˆç†
            print(f"è­¦å‘Š: å‚æ•°næ— æ³•æ”¶æ•› - {e}")
            return None
```

**å¤±è´¥æ¡ˆä¾‹å¤„ç†**:
- å½“ `Q/P > 1 - 1/Ï†^n_max` (Ï†=PET/P) æ—¶ï¼Œæ–¹ç¨‹æ— å®æ•°è§£
- å»ºè®®é¢„å…ˆè¿‡æ»¤ï¼šä»…å¯¹ `0.05 < Q/P < 0.95` çš„æ•°æ®è¿›è¡Œç‡å®š

---

#### æ¨¡å—6: `elasticity_solver.py`
**ç›®æ ‡**: è®¡ç®—å¾„æµå¼¹æ€§ç³»æ•°

```python
def calculate_elasticity_P(P, PET, n):
    """é™æ°´å¼¹æ€§ç³»æ•° ÎµP"""
    phi = PET / P
    phi_n = phi**n
    
    term1 = phi_n / (1 + phi_n)
    numerator = 1 - term1**(1/n + 1)
    denominator = 1 - term1**(1/n)
    
    return numerator / denominator

def calculate_elasticity_PET(P, PET, n):
    """PETå¼¹æ€§ç³»æ•° ÎµPET"""
    phi = PET / P
    phi_n = phi**n
    
    term1 = 1 / (1 + phi_n)
    term2 = 1 / (1 - ((1 + phi_n) / phi_n)**(1/n))
    
    return term1 * term2

def calculate_elasticity_n(P, PET, n):
    """æµåŸŸå‚æ•°å¼¹æ€§ç³»æ•° Îµn"""
    phi = P / PET  # æ³¨æ„ï¼šè¿™é‡Œæ˜¯P/PET
    phi_n = phi**n
    
    term1 = 1 / ((1 + phi_n)**(1/n) - 1)
    
    ln_P = np.log(P)
    ln_PET = np.log(PET)
    ln_sum = np.log(P**n + PET**n)
    
    term2 = (P**n * ln_P + PET**n * ln_PET) / (P**n + PET**n) - ln_sum / n
    
    return term1 * term2
```

**å•å…ƒæµ‹è¯•å»ºè®®**:
```python
def test_elasticity_sum():
    """æ£€éªŒÎµP + ÎµPETçš„å…³ç³»"""
    P, PET, n = 800, 1200, 2.5
    eps_P = calculate_elasticity_P(P, PET, n)
    eps_PET = calculate_elasticity_PET(P, PET, n)
    
    # å¯¹äºæŸäº›Budykoå…¬å¼ï¼ŒÎµP + ÎµPET â‰ˆ 1ï¼ˆè½¯çº¦æŸï¼‰
    # Choudhury-Yangå…¬å¼å¯èƒ½ç•¥æœ‰åå·®
    assert 0.5 < eps_P + eps_PET < 1.5, "å¼¹æ€§ç³»æ•°ä¹‹å’Œå¼‚å¸¸"
```

---

### é˜¶æ®µä¸‰ï¼šå½’å› åˆ†æå±‚ï¼ˆç¬¬5-6å‘¨ï¼‰

**ä¼˜å…ˆçº§: â­â­â­â­**

#### æ¨¡å—7: `budyko_attribution.py`
**ç›®æ ‡**: å®ç°å½’å› åˆ†æä¸»æµç¨‹

```python
class BudykoAttribution:
    def __init__(self, station_data):
        """
        station_data: DataFrameåŒ…å«åˆ— ['year', 'P', 'PET', 'Qn', 'Qo']
        """
        self.data = station_data
        
    def set_periods(self, change_year=1986):
        """åˆ’åˆ†åŸºå‡†æœŸå’Œå˜åŒ–æœŸ"""
        self.pre_period = self.data[self.data['year'] < change_year]
        self.post_period = self.data[self.data['year'] >= change_year]
        
    def run_attribution(self):
        """æ‰§è¡Œå®Œæ•´å½’å› æµç¨‹ï¼ˆå¯¹åº”main.texçš„6ä¸ªæ­¥éª¤ï¼‰"""
        
        # Step 1: å…¨æ—¶æ®µå‚æ•°ç‡å®š
        P_full = self.data['P'].mean()
        PET_full = self.data['PET'].mean()
        Qn_full = self.data['Qn'].mean()
        
        calibrator = BudykoCalibrator(P_full, PET_full, Qn_full)
        n_full = calibrator.calibrate_n()
        
        if n_full is None:
            raise ValueError("å‚æ•°nç‡å®šå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®è´¨é‡")
        
        # Step 2: è®¡ç®—å¼¹æ€§ç³»æ•°ï¼ˆä½¿ç”¨å…¨æ—¶æ®µå‡å€¼ï¼‰
        eps_P = calculate_elasticity_P(P_full, PET_full, n_full)
        eps_PET = calculate_elasticity_PET(P_full, PET_full, n_full)
        eps_n = calculate_elasticity_n(P_full, PET_full, n_full)
        
        # Step 3: åˆ†æ—¶æ®µå‚æ•°ç‡å®š
        P_pre = self.pre_period['P'].mean()
        PET_pre = self.pre_period['PET'].mean()
        Qn_pre = self.pre_period['Qn'].mean()
        
        P_post = self.post_period['P'].mean()
        PET_post = self.post_period['PET'].mean()
        Qn_post = self.post_period['Qn'].mean()
        
        n_pre = BudykoCalibrator(P_pre, PET_pre, Qn_pre).calibrate_n()
        n_post = BudykoCalibrator(P_post, PET_post, Qn_post).calibrate_n()
        
        # Step 4: è®¡ç®—å˜åŒ–é‡
        delta_P = P_post - P_pre
        delta_PET = PET_post - PET_pre
        delta_n = n_post - n_pre
        
        # è®¡ç®—å„é©±åŠ¨å› å­çš„è´¡çŒ®ï¼ˆç»å¯¹é‡ï¼Œmmï¼‰
        delta_Qn_CCV = (eps_P * Qn_full / P_full * delta_P + 
                        eps_PET * Qn_full / PET_full * delta_PET)
        
        delta_Qn_LUCC = eps_n * Qn_full / n_full * delta_n
        
        delta_Qn_total = delta_Qn_CCV + delta_Qn_LUCC
        
        # Step 5: è®¡ç®—è´¡çŒ®ç‡ï¼ˆ%ï¼‰
        Qo_pre = self.pre_period['Qo'].mean()
        Qo_post = self.post_period['Qo'].mean()
        delta_Qo = Qo_post - Qo_pre
        
        if abs(delta_Qo) < 1:  # é˜ˆå€¼ï¼š1mm
            print("è­¦å‘Š: å¾„æµå˜åŒ–è¿‡å°ï¼Œè´¡çŒ®ç‡è®¡ç®—ä¸ç¨³å®š")
            return None
        
        C_CCV = delta_Qn_CCV / delta_Qo * 100
        C_LUCC = delta_Qn_LUCC / delta_Qo * 100
        C_WADR = (delta_Qo - (Qn_post - Qn_pre)) / delta_Qo * 100
        
        # Step 6: è¿”å›ç»“æœå­—å…¸
        return {
            'n_full': n_full,
            'n_pre': n_pre,
            'n_post': n_post,
            'delta_Qo': delta_Qo,
            'delta_Qn_CCV': delta_Qn_CCV,
            'delta_Qn_LUCC': delta_Qn_LUCC,
            'C_CCV': C_CCV,
            'C_LUCC': C_LUCC,
            'C_WADR': C_WADR,
            'elasticity': {
                'eps_P': eps_P,
                'eps_PET': eps_PET,
                'eps_n': eps_n
            }
        }
```

---

### é˜¶æ®µå››ï¼šé«˜çº§åŠŸèƒ½ä¸éªŒè¯ï¼ˆç¬¬7-8å‘¨ï¼‰

**ä¼˜å…ˆçº§: â­â­â­**

#### æ¨¡å—8: `isimip_attribution.py`
**ç›®æ ‡**: åŸºäºISIMIPæ¨¡å‹è¾“å‡ºçš„å½’å› åˆ†æ

```python
class ISIMIPAttribution:
    def __init__(self, model_outputs):
        """
        model_outputs: dictåŒ…å«
            - 'Qo_prime': obsclim + histsoc
            - 'Qn_prime': obsclim + 1901soc
            - 'Qcn_prime': counterclim + 1901soc
        """
        self.Q_o = model_outputs['Qo_prime']
        self.Q_n = model_outputs['Qn_prime']
        self.Q_cn = model_outputs['Qcn_prime']
        
    def calculate_contributions(self, delta_Qo_obs):
        """
        åˆ†ç¦»ACCï¼ˆäººä¸ºæ°”å€™å˜åŒ–ï¼‰å’ŒNCVï¼ˆè‡ªç„¶æ°”å€™å˜ç‡ï¼‰
        """
        delta_Qn_prime = self.Q_n['post'].mean() - self.Q_n['pre'].mean()
        delta_Qcn_prime = self.Q_cn['post'].mean() - self.Q_cn['pre'].mean()
        delta_Qn_obs = ... # ä»è§‚æµ‹æ•°æ®è®¡ç®—
        
        C_CCV = delta_Qn_prime / delta_Qo_obs * 100
        C_ACC = (delta_Qn_prime - delta_Qcn_prime) / delta_Qo_obs * 100
        C_NCV = delta_Qcn_prime / delta_Qo_obs * 100
        C_LUCC = (delta_Qn_obs - delta_Qn_prime) / delta_Qo_obs * 100
        
        return {
            'C_CCV': C_CCV,
            'C_ACC': C_ACC,
            'C_NCV': C_NCV,
            'C_LUCC': C_LUCC
        }
```

---

## ä¸‰ã€å…³é”®æŠ€æœ¯é€‰å‹ä¸æœ€ä½³å®è·µ

### 3.1 æ ¸å¿ƒä¾èµ–åº“

```yaml
# environment.yml
name: budyko-env
channels:
  - conda-forge
dependencies:
  - python=3.10
  - numpy>=1.24
  - pandas>=2.0
  - xarray>=2023.1
  - rioxarray>=0.13
  - geopandas>=0.12
  - scipy>=1.10
  - pyet>=1.3          # PETè®¡ç®—
  - netCDF4>=1.6
  - dask>=2023.1       # å¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—
  - matplotlib>=3.7
  - seaborn>=0.12
  - pytest>=7.2        # å•å…ƒæµ‹è¯•
  - black              # ä»£ç æ ¼å¼åŒ–
  - jupyter
```

### 3.2 é…ç½®æ–‡ä»¶è®¾è®¡

```yaml
# config/config.yaml
data:
  grdc_dir: "data/raw/GRDC/"
  isimip_dir: "data/raw/ISIMIP3a/"
  huang_dir: "data/raw/WaterUse/"
  basin_shp: "data/shapefiles/basins.shp"
  
parameters:
  change_year: 1986
  base_period: [1960, 1985]
  impact_period: [1986, 2016]
  n_bounds: [0.1, 10]
  missing_threshold: 0.15  # 15%ç¼ºæµ‹é˜ˆå€¼
  
quality_checks:
  min_runoff_ratio: 0.05
  max_runoff_ratio: 0.95
  min_delta_Q: 1.0  # mm
  
output:
  results_dir: "data/results/"
  figures_dir: "figures/"
  log_level: "INFO"
```

### 3.3 ä¸»è¿è¡Œè„šæœ¬ç¤ºä¾‹

```python
# main.py
import yaml
import logging
from src.data_preprocessing import GRDCParser, ClimateDataProcessor
from src.budyko_model import BudykoCalibrator
from src.attribution import BudykoAttribution

def main():
    # åŠ è½½é…ç½®
    with open('config/config.yaml', 'r') as f:
        config = yaml.safe_load(f)
    
    # åˆå§‹åŒ–æ—¥å¿—
    logging.basicConfig(level=config['output']['log_level'])
    logger = logging.getLogger(__name__)
    
    # æ•°æ®åŠ è½½
    logger.info("åŠ è½½GRDCæ•°æ®...")
    grdc = GRDCParser(config['data']['grdc_dir'])
    stations = grdc.load_all_stations()
    
    results = []
    
    for station_id, station_data in stations.items():
        logger.info(f"å¤„ç†ç«™ç‚¹ {station_id}...")
        
        try:
            # å½’å› åˆ†æ
            attribution = BudykoAttribution(station_data)
            attribution.set_periods(config['parameters']['change_year'])
            result = attribution.run_attribution()
            
            if result is not None:
                result['station_id'] = station_id
                results.append(result)
        
        except Exception as e:
            logger.error(f"ç«™ç‚¹ {station_id} å¤„ç†å¤±è´¥: {e}")
            continue
    
    # ä¿å­˜ç»“æœ
    import pandas as pd
    df_results = pd.DataFrame(results)
    df_results.to_csv(f"{config['output']['results_dir']}/attribution_results.csv", 
                      index=False)
    logger.info(f"å®Œæˆï¼å…±å¤„ç† {len(results)} ä¸ªç«™ç‚¹")

if __name__ == "__main__":
    main()
```

---

## å››ã€æ•°æ®è´¨é‡æ§åˆ¶ä¸éªŒè¯ç­–ç•¥

### 4.1 å¿…é¡»å®ç°çš„æ£€éªŒå‡½æ•°

```python
# src/validation/quality_checks.py

class QualityChecker:
    @staticmethod
    def check_water_balance(P, Q, E, tolerance=0.1):
        """
        æ£€æŸ¥: |P - Q - E| / P < tolerance
        """
        residual = abs(P - Q - E)
        return residual / P < tolerance
    
    @staticmethod
    def check_runoff_ratio(Q, P):
        """
        æ£€æŸ¥: 0.05 < Q/P < 0.95
        """
        ratio = Q / P
        return 0.05 <= ratio <= 0.95
    
    @staticmethod
    def check_parameter_range(n):
        """
        æ£€æŸ¥: 0.1 < n < 10ï¼ˆç»éªŒèŒƒå›´ï¼‰
        """
        return 0.1 <= n <= 10
    
    @staticmethod
    def check_elasticity_signs(eps_P, eps_PET, eps_n):
        """
        æ£€æŸ¥ç¬¦å·åˆç†æ€§:
        - ÎµP > 0 (é™æ°´å¢åŠ â†’å¾„æµå¢åŠ )
        - ÎµPET < 0 (è’¸æ•£å‘éœ€æ±‚å¢åŠ â†’å¾„æµå‡å°‘)
        - Îµn < 0 (æˆªç•™èƒ½åŠ›å¢åŠ â†’å¾„æµå‡å°‘)
        """
        return eps_P > 0 and eps_PET < 0 and eps_n < 0
```

### 4.2 å•å…ƒæµ‹è¯•æ¡†æ¶

```python
# tests/test_budyko_model.py
import pytest
from src.budyko_model import budyko_runoff, BudykoCalibrator

def test_budyko_extreme_dry():
    """æµ‹è¯•æç«¯å¹²æ—±æƒ…å†µ (P << PET)"""
    Q = budyko_runoff(P=200, PET=2000, n=2.5)
    assert Q < 50, "æç«¯å¹²æ—±æ—¶å¾„æµåº”å¾ˆå°"

def test_budyko_extreme_wet():
    """æµ‹è¯•æç«¯æ¹¿æ¶¦æƒ…å†µ (P >> PET)"""
    Q = budyko_runoff(P=2000, PET=500, n=2.5)
    assert Q > 1400, "æç«¯æ¹¿æ¶¦æ—¶å¾„æµåº”æ¥è¿‘P-PET"

def test_parameter_inversion():
    """æµ‹è¯•å‚æ•°åæ¼”çš„æ”¶æ•›æ€§"""
    P, PET = 800, 1200
    n_true = 2.5
    Q_true = budyko_runoff(P, PET, n_true)
    
    calibrator = BudykoCalibrator(P, PET, Q_true)
    n_inv = calibrator.calibrate_n()
    
    assert abs(n_inv - n_true) < 0.01, "å‚æ•°åæ¼”è¯¯å·®è¿‡å¤§"
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–ä¸å¤§è§„æ¨¡è®¡ç®—

### 5.1 å¹¶è¡ŒåŒ–ç­–ç•¥

```python
# ä½¿ç”¨Daskå¹¶è¡Œå¤„ç†å¤šä¸ªç«™ç‚¹
import dask
from dask import delayed
import dask.dataframe as dd

@delayed
def process_one_station(station_id, data):
    """å•ç«™ç‚¹å¤„ç†ï¼ˆåŒ…è£…ä¸ºå»¶è¿Ÿå‡½æ•°ï¼‰"""
    attribution = BudykoAttribution(data)
    return attribution.run_attribution()

# æ‰¹é‡å¹¶è¡Œ
results = []
for sid, data in stations.items():
    result = process_one_station(sid, data)
    results.append(result)

# è§¦å‘è®¡ç®—ï¼ˆè‡ªåŠ¨å¤šæ ¸å¹¶è¡Œï¼‰
computed_results = dask.compute(*results, scheduler='processes')
```

### 5.2 å†…å­˜ç®¡ç†æŠ€å·§

```python
# å¤„ç†å¤§å‹NetCDFæ–‡ä»¶æ—¶ä½¿ç”¨chunking
import xarray as xr

ds = xr.open_mfdataset(
    'data/ISIMIP/*.nc',
    chunks={'time': 365, 'lat': 50, 'lon': 50},  # åˆ†å—åŠ è½½
    parallel=True
)

# å»¶è¿Ÿè®¡ç®—ï¼Œä»…åœ¨éœ€è¦æ—¶è§¦å‘
annual_mean = ds['pr'].resample(time='1Y').mean()
result = annual_mean.compute()  # è§¦å‘å®é™…è®¡ç®—
```

---

## å…­ã€ç§‘å­¦è®¡ç®—æ³¨æ„äº‹é¡¹

### 6.1 æ•°å€¼ç¨³å®šæ€§

```python
# é¿å…é™¤é›¶é”™è¯¯
def safe_divide(numerator, denominator, fill_value=np.nan):
    """å®‰å…¨é™¤æ³•ï¼Œåˆ†æ¯ä¸º0æ—¶è¿”å›fill_value"""
    with np.errstate(divide='ignore', invalid='ignore'):
        result = numerator / denominator
        result[~np.isfinite(result)] = fill_value
    return result

# é¿å…å¯¹æ•°è¿ç®—é”™è¯¯
def safe_log(x, epsilon=1e-10):
    """å®‰å…¨å¯¹æ•°ï¼Œç¡®ä¿è¾“å…¥ > 0"""
    return np.log(np.maximum(x, epsilon))
```

### 6.2 å•ä½è½¬æ¢æ¸…å•

| å˜é‡ | ISIMIPåŸå§‹å•ä½ | Budykoæ‰€éœ€å•ä½ | è½¬æ¢å…¬å¼ |
|------|---------------|---------------|----------|
| é™æ°´ pr | kgÂ·mâ»Â²Â·sâ»Â¹ | mm/year | `Ã— 86400 Ã— 365.25` |
| æ°”æ¸© tas | K | Â°C | `- 273.15` |
| è¾å°„ rsds | WÂ·mâ»Â² | MJÂ·mâ»Â²Â·dayâ»Â¹ | `Ã— 0.0864` |
| å¾„æµ dis | mÂ³Â·sâ»Â¹ | mm/year | `Ã— 86400 Ã— 365.25 / (Area_kmÂ² Ã— 1e6) Ã— 1000` |

---

## ä¸ƒã€ä»£ç å¼€å‘æ—¶é—´çº¿ï¼ˆ8å‘¨è®¡åˆ’ï¼‰

| å‘¨æ¬¡ | ä»»åŠ¡ | äº¤ä»˜æˆæœ | éªŒè¯æ ‡å‡† |
|------|------|---------|---------|
| 1-2 | æ•°æ®é¢„å¤„ç†æ¨¡å— | `grdc_parser.py`, `climate_processor.py` | èƒ½æˆåŠŸåŠ è½½å¹¶è½¬æ¢è‡³å°‘5ä¸ªGRDCç«™ç‚¹ |
| 3-4 | Budykoæ ¸å¿ƒæ¨¡å‹ | `core_equations.py`, `parameter_calibration.py` | å‚æ•°nåæ¼”è¯¯å·® < 1% |
| 5-6 | å½’å› åˆ†æä¸»æµç¨‹ | `budyko_attribution.py` | å¤ç°main.texä¸­çš„è®¡ç®—æ­¥éª¤ |
| 7 | é«˜çº§åŠŸèƒ½ | `isimip_attribution.py` | æˆåŠŸåˆ†ç¦»ACCå’ŒNCV |
| 8 | æµ‹è¯•ä¸æ–‡æ¡£ | å•å…ƒæµ‹è¯• + APIæ–‡æ¡£ | æµ‹è¯•è¦†ç›–ç‡ > 80% |

---

## å…«ã€å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

### é™·é˜±1: æ—¶é—´å°ºåº¦æ··æ·†
**é—®é¢˜**: å°†æ—¥å°ºåº¦çš„PETç›´æ¥ç”¨äºå¹´å°ºåº¦çš„Budykoæ–¹ç¨‹  
**è§£å†³**: å…ˆèšåˆä¸ºå¹´æ€»é‡ï¼Œå†è¾“å…¥æ¨¡å‹

### é™·é˜±2: åæ ‡ç³»ä¸åŒ¹é…
**é—®é¢˜**: ISIMIPæ•°æ®(WGS84)ä¸æµåŸŸè¾¹ç•Œ(å…¶ä»–æŠ•å½±)ä¸ä¸€è‡´  
**è§£å†³**: ç»Ÿä¸€é‡æŠ•å½±åˆ°WGS84 (EPSG:4326)

### é™·é˜±3: å‚æ•°næ— è§£
**é—®é¢˜**: æŸäº›ç«™ç‚¹çš„Q/Pæ¯”ä¾‹è¶…å‡ºBudykoæ›²çº¿èŒƒå›´  
**è§£å†³**: é¢„å…ˆç­›é€‰ + æ·»åŠ try-except + è®°å½•å¤±è´¥æ—¥å¿—

### é™·é˜±4: è´¡çŒ®ç‡ä¹‹å’Œä¸ä¸º100%
**åŸå› **: è§‚æµ‹å¾„æµQoä¸å¤©ç„¶å¾„æµQnå­˜åœ¨ç³»ç»Ÿæ€§åå·®  
**å¤„ç†**: è¿™æ˜¯æ­£å¸¸ç°è±¡ï¼Œä¸å¼ºåˆ¶å½’ä¸€åŒ–ï¼ˆé™¤éç”¨æˆ·æ˜ç¡®è¦æ±‚ï¼‰

---

## ä¹ã€æ¨èå­¦ä¹ èµ„æº

1. **Budykoç†è®ºæ·±å…¥**:  
   - Xu et al. (2013) "Technical Note: Analytical inversion of the parametric Budyko equations"
   
2. **Pythonæ°´æ–‡è®¡ç®—**:  
   - `pyet`æ–‡æ¡£: https://pyet.readthedocs.io/
   - `xarray`æ•™ç¨‹: https://tutorial.xarray.dev/
   
3. **ç©ºé—´åˆ†æ**:  
   - `rioxarray`æŒ‡å—: https://corteva.github.io/rioxarray/
   
4. **å‚è€ƒä»£ç **:  
   - https://github.com/amforte/Caucasus_Erosion/blob/main/budyko.py

---

## åã€æœ€ç»ˆæ£€æŸ¥æ¸…å•

åœ¨æäº¤ä»£ç å‰ï¼Œç¡®è®¤ä»¥ä¸‹äº‹é¡¹ï¼š

- [ ] æ‰€æœ‰æ¨¡å—éƒ½æœ‰è¯¦ç»†çš„docstringï¼ˆGoogleé£æ ¼ï¼‰
- [ ] å…³é”®å‡½æ•°åŒ…å«ç±»å‹æç¤ºï¼ˆType Hintsï¼‰
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- [ ] ç‰©ç†ä¸€è‡´æ€§æ£€æŸ¥è´¯ç©¿å§‹ç»ˆ
- [ ] é…ç½®æ–‡ä»¶ä¸ä»£ç è§£è€¦
- [ ] ç”Ÿæˆçš„ç»“æœå¯è¿½æº¯ï¼ˆåŒ…å«å…ƒæ•°æ®ï¼‰
- [ ] READMEåŒ…å«å®Œæ•´çš„å®‰è£…å’Œä½¿ç”¨ç¤ºä¾‹
- [ ] ä»£ç é€šè¿‡`black`å’Œ`flake8`æ£€æŸ¥
- [ ] è‡³å°‘ä¸€ä¸ªå®Œæ•´çš„æ¡ˆä¾‹ç ”ç©¶ï¼ˆJupyter Notebookï¼‰
- [ ] æ‰€æœ‰æ•°æ®è·¯å¾„ä½¿ç”¨ç›¸å¯¹è·¯å¾„æˆ–é…ç½®æ–‡ä»¶

---

**æœ€åå»ºè®®**: ä»æœ€ç®€å•çš„å•ç«™ç‚¹æ¡ˆä¾‹å¼€å§‹ï¼ˆé€‰æ‹©æ•°æ®å®Œæ•´çš„ç«™ç‚¹ï¼‰ï¼Œé€æ­¥éªŒè¯æ¯ä¸ªæ¨¡å—çš„æ­£ç¡®æ€§ï¼Œå†æ‰©å±•åˆ°æ‰¹é‡å¤„ç†ã€‚ä¿æŒ"å…ˆèƒ½è·‘é€šï¼Œå†ä¼˜åŒ–"çš„åŸåˆ™ã€‚

ç¥ç ”ç©¶é¡ºåˆ©ï¼ğŸš€
